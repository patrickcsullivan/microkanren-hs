module Main where

import Data.List (transpose)
import Data.Maybe (fromMaybe)

-- Mostly copied from https://github.com/seantalts/hasktrip/blob/master/doc/MicroKanren.md

main :: IO ()
main = mkTests

data Term
  = Var Int -- Logic variable identified by an index
  | Atom String
  deriving (Eq, Show)

-- | Association list of substitions.
type Substitution = [(Term, Term)]

-- | Recursively walk through the substitution list to determine what a given
-- term is associated with.
-- walk [ (Var 0, Var 1) ] (Var 0) = Var 1
walk :: Substitution -> Term -> Term
walk s x@(Var _) =
  let -- Try to lookup the term in the substitution.
      firstLookup = lookup x s
      -- If first lookup succeeded, try to lookup next assoc.
      -- If first lookup found an atom, this will just return the atom.
      -- If first lookup found a var, this will try to find the var's association.
      nextLookup = fmap (walk s) firstLookup
   in -- Lookup will fail if it ever walked into a var for which there is no
      -- association.
      fromMaybe x nextLookup
-- Looking up an atom trivially succeeds.
walk _ x = x

-- | Try to unify the terms within the given substitution, returing the new
-- substitution required for unification (ie, required to satisfy the equation).
unify :: Term -> Term -> Substitution -> Maybe Substitution
unify lhs rhs subs =
  -- Either...
  -- unifiedWalkResult is Nothing -> No way to unify so return Nothing.
  -- unifiedWalkResuls is Some ->
  --    The terms can be unified WITH the new substitions, so add the new subs
  --    to the input subs and return the result.
  (++ subs) <$> unifiedWalkResults
  where
    -- Walk to find the association of both the lhs and rhs.
    unifiedWalkResults = unifyExpr walkLhs walkRhs
    walkLhs = walk subs lhs
    walkRhs = walk subs rhs

    -- unifyExpr determines the substitions necessary to unify the two sides.
    unifyExpr :: Term -> Term -> Maybe Substitution
    -- The two sides unify with no additional substitions.
    unifyExpr (Atom a) (Atom b) | a == b = return []
    -- The two sides unify if the lhs var unifies with the rhs var/atom.
    unifyExpr l@(Var _) r = return [(l, r)]
    -- The two sides unify if the rhs var unifies with the lhs atom.
    unifyExpr l r@(Var _) = return [(r, l)]
    -- No way for the two sides to unify. (Disequal atoms.)
    unifyExpr _ _ = Nothing

-- GOAL: A constraint. Takes a pre-existing context, (Substition, Int), for a
-- logical program and generates additional possible/satisfying contexts.
-- ---
-- > Takes a substition and a logic variable index representing the next
-- available logic variable.
-- > Returns a list of new substitutions satisfying the given goal, along with
-- the next available logic variable for each substitution.
type Goal = (Substitution, Int) -> [(Substitution, Int)]

-- A "Goal" is a central idea. It takes some context and generates a list of
-- contexts that are each satisfying. Each goal is a valid logic program by
-- itself. Later, we will compose them into larger programs.
-- 1.)
-- `Var 1 === Var 0` We can get the list of possible satisfying
-- contexts by passing in a starting context.
-- 2.)
-- `fresh (\ newLVar -> newLVar === Var 0 )` We can get a list of possible
-- contexts that are satisfying by passing in a starting context, and new logic
-- vars will be generated by fresh

-- ---
-- API
-- ---

-- | Sets two sides of an equation equal to each other by returning a Goal,
-- which maps a substition and logic var index into a list of satisfying
-- substitutions.
--
-- Returns "Goal" that unifies the two terms, where a "Goal" is basically a
-- function for generating substitions from given contexts.
(===) :: Term -> Term -> Goal
(a === b) (sub, c) =
  case unify a b sub of
    -- There are no substitutions that can satisfy the equation for the given
    -- substition.
    Nothing -> []
    -- The substition returned by unification can satisfy the equation for the
    -- given substitution. The next available logic var index doesn't change
    -- since no new logic var was introduced.
    (Just sub') -> return (sub', c)

-- | Introduce a new logic variable into a goal.
-- ...takes a function that returns at Goal for a given term, where the "Goal"
-- is a function for generating satisfying substitutions from given
-- .contexts/substitutions.
-- ...returns a Goal (function for generating substitutions from a given ctx)
fresh :: (Term -> Goal) -> Goal
fresh f (sub, idx) =
  -- sub and idx are the input context for the Goal we'll return.
  -- Generate a Goal using the next free logic var, as specified by the input
  -- context.
  let innerGoal = f (Var idx)
   in -- Apply the generated goal to the sub from the input context, using idx+1 as
      -- the next free logic var, since we just used idx in generating the inner
      -- Goal.
      innerGoal (sub, idx + 1)

-- | Returns a Goal that, when given a starting ctx, returns a list of ctxs that
-- satisfy the first goal or second goal. Alternates between the two potentially
-- infinitely.
disj :: Goal -> Goal -> Goal
disj g1 g2 sc =
  (concat . transpose)
    [ g1 sc, -- potentially infinite list of satisfying subs/ctxs for g1, using input ctx
      g2 sc -- potentially infinite list of satisfying subs/ctxs for g2, using input ctx
    ]

conj :: Goal -> Goal -> Goal
-- Feed each of the satisfying ctx from `g1 sc` into `g2`.
conj g1 g2 sc = g1 sc >>= g2

emptyState :: (Substitution, Int)
emptyState = ([], 0)

aAndB :: Goal
aAndB =
  conj
    (fresh (\a -> a === Atom "7"))
    ( fresh
        ( \b ->
            disj
              (b === Atom "5")
              (b === Atom "6")
        )
    )

fives :: Term -> Goal
fives x = disj (x === Atom "5") (fives x) -- Seach will keep finding same result. Goal generates list of infinite substitutions.

sixes :: Term -> Goal
sixes x = disj (x === Atom "6") (sixes x) -- Search will keep finding same result.

fivesOrSixes :: Goal
fivesOrSixes = fresh $ \x -> disj (fives x) (sixes x)

badInf :: Goal
badInf =
  fresh $ \x ->
    conj
      (x === Atom "6")
      (fives x) -- Tries to unify (Var 0 === "6") with "5" forever

badInf2 :: Goal
badInf2 =
  fresh $ \x ->
    conj
      (fives x) -- Tries to unify (Var 0 === "6") with "5" forever
      (x === Atom "6")

mkTests :: IO ()
mkTests = do
  -- print $ aAndB emptyState
  -- -- Could have used fresh but didn't need it since we know Var 0 is available,
  -- -- but this does mean the "next free var" in the output context is wrong.
  -- print $ take 4 $ fives (Var 0) emptyState
  -- print $ take 6 $ fivesOrSixes emptyState
  print $ take 2 $ badInf emptyState